<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Voice Diary</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <script>
        // Apply theme from localStorage immediately to prevent FOUC (Flash of Unstyled Content)
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .pulse-red { animation: pulse-red-animation 1.5s infinite; }
        @keyframes pulse-red-animation {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }
        .pulse-green { animation: pulse-green-animation 1.5s infinite; }
        @keyframes pulse-green-animation {
            0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(34, 197, 94, 0); }
            100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); }
        }
        .toast {
            visibility: hidden; opacity: 0;
            min-width: 250px; margin-left: -125px;
            background-color: #333; color: #fff; text-align: center;
            border-radius: 8px; padding: 16px; position: fixed;
            z-index: 50; left: 50%; bottom: 30px;
            transition: visibility 0.3s, opacity 0.3s linear;
        }
        .toast.show { visibility: visible; opacity: 1; }
        #entries-list::-webkit-scrollbar { width: 8px; }
        #entries-list::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        #entries-list::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        .dark #entries-list::-webkit-scrollbar-track { background: #4b5563; }
        .dark #entries-list::-webkit-scrollbar-thumb { background: #6b7280; }
        .modal-overlay { transition: opacity 0.3s ease-in-out; }
        .modal-content { transition: transform 0.3s ease-in-out; }
        .mood-selector span { transition: transform 0.2s; }
        .mood-selector span:hover { transform: scale(1.2); }
        .mood-selector span.selected { background-color: #dbeafe; border-radius: 50%; }
        .dark .mood-selector span.selected { background-color: #374151; }
        
        #diary-text {
            width: 100%; height: 100%;
            background: transparent;
            padding: 1rem;
            outline: none;
            resize: none;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        /* CSS Placeholder for contenteditable div */
        #diary-text:empty::before {
            content: attr(placeholder);
            color: #9ca3af; /* Tailwind gray-400 */
            cursor: text;
            pointer-events: none;
        }
        .dark #diary-text:empty::before {
            color: #6b7280; /* Tailwind gray-500 */
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen transition-colors duration-300">
    <div class="container mx-auto max-w-4xl p-4 md:p-8">
        
        <header class="text-center mb-8 relative">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-800 dark:text-white">Interactive Voice Diary</h1>
            <p class="text-gray-500 dark:text-gray-400 mt-2">Speak, listen, and reflect on your personal history.</p>
            <button id="theme-toggle" class="absolute top-0 right-0 p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none">
                <svg id="theme-icon-light" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path></svg>
                <svg id="theme-icon-dark" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path></svg>
            </button>
        </header>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
            
            <!-- Left Side: Editor -->
            <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 flex flex-col">
                <h2 class="text-2xl font-bold mb-4 text-gray-800 dark:text-white">New Entry</h2>
                
                <div id="controls" class="grid grid-cols-2 gap-4 my-4">
                    <div class="flex flex-col items-center justify-center space-y-2">
                        <button id="record-btn" class="w-16 h-16 bg-red-500 rounded-full flex items-center justify-center text-white transition-transform duration-200 hover:scale-110 focus:outline-none focus:ring-4 focus:ring-red-300 dark:focus:ring-red-800 disabled:opacity-50 disabled:cursor-not-allowed">
                           <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="currentColor" viewBox="0 0 16 16"><path d="M5 3a3 3 0 0 1 6 0v5a3 3 0 0 1-6 0V3z"/><path d="M3.5 6.5A.5.5 0 0 1 4 7v1a4 4 0 0 0 8 0V7a.5.5 0 0 1 1 0v1a5 5 0 0 1-4.5 4.975V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 .5-.5z"/></svg>
                        </button>
                        <p id="record-status" class="text-gray-600 dark:text-gray-400 text-sm text-center">Tap to start recording</p>
                    </div>
                     <div class="flex flex-col items-center justify-center space-y-2">
                        <button id="listen-btn" class="w-16 h-16 bg-green-500 rounded-full flex items-center justify-center text-white transition-transform duration-200 hover:scale-110 focus:outline-none focus:ring-4 focus:ring-green-300 dark:focus:ring-green-800 disabled:opacity-50 disabled:cursor-not-allowed">
                           <svg id="listen-icon-play" xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="currentColor" viewBox="0 0 16 16"><path d="M11.596 8.697l-6.363 3.692c-.54.313-1.233-.066-1.233-.697V4.308c0-.63.692-1.01 1.233-.696l6.363 3.692a.802.802 0 0 1 0 1.393z"/></svg>
                           <svg id="listen-icon-pause" xmlns="http://www.w3.org/2000/svg" width="28" height="28" fill="currentColor" class="hidden" viewBox="0 0 16 16"><path d="M5.5 3.5A1.5 1.5 0 0 1 7 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5zm5 0A1.5 1.5 0 0 1 12 5v6a1.5 1.5 0 0 1-3 0V5a1.5 1.5 0 0 1 1.5-1.5z"/></svg>
                        </button>
                        <p id="listen-status" class="text-gray-600 dark:text-gray-400 text-sm text-center">Tap to listen</p>
                    </div>
                </div>
                
                <div class="flex-grow flex flex-col bg-gray-50 dark:bg-gray-700 rounded-lg border border-gray-200 dark:border-gray-600">
                    <div id="diary-text" contenteditable="true" class="text-gray-800 dark:text-gray-200" placeholder="Your transcribed thoughts will appear here..."></div>
                </div>

                <div class="mt-4 flex items-center justify-between gap-4">
                     <select id="language-select" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                        <option value="en-US">English</option><option value="ta-IN">Tamil</option>
                    </select>
                     <select id="speed-select" class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block p-2.5 dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                        <option value="0.5">0.50x</option>
                        <option value="0.75">0.75x</option>
                        <option value="1" selected>1x</option>
                        <option value="1.5">1.5x</option>
                        <option value="2">2x</option>
                    </select>
                    <button id="save-btn" class="flex-shrink-0 px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">
                        Save
                    </button>
                </div>
            </div>

            <!-- Right Side: Past Entries -->
            <div class="bg-white dark:bg-gray-800 rounded-2xl shadow-lg p-6 flex flex-col">
                <h2 class="text-2xl font-bold text-gray-800 dark:text-white mb-4">History</h2>
                <input type="text" id="search-bar" class="w-full p-2 mb-4 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg" placeholder="Search entries...">
                <div id="entries-list" class="flex-grow overflow-y-auto pr-2 space-y-4">
                    <p id="no-entries-msg" class="text-gray-500 dark:text-gray-400">You have no saved entries yet.</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Save/Edit Modal -->
    <div id="save-modal" class="modal-overlay fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden">
        <div class="modal-content bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md transform scale-95">
            <h3 id="modal-title" class="text-xl font-bold mb-4">Save New Entry</h3>
            <div class="space-y-4">
                <input type="text" id="modal-title-input" placeholder="Enter a title for your entry" class="w-full p-2 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                <textarea id="modal-text-input" rows="6" class="w-full p-2 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"></textarea>
                <div>
                    <label class="block mb-2 text-sm font-medium text-gray-700 dark:text-gray-300">Select a mood:</label>
                    <div class="mood-selector flex justify-around p-2 bg-gray-100 dark:bg-gray-700 rounded-lg">
                        <span data-mood="ðŸ˜Š" class="cursor-pointer p-2 text-2xl">ðŸ˜Š</span>
                        <span data-mood="ðŸ¤”" class="cursor-pointer p-2 text-2xl">ðŸ¤”</span>
                        <span data-mood="ðŸ˜¢" class="cursor-pointer p-2 text-2xl">ðŸ˜¢</span>
                        <span data-mood="ðŸŽ‰" class="cursor-pointer p-2 text-2xl">ðŸŽ‰</span>
                        <span data-mood="ðŸ’¡" class="cursor-pointer p-2 text-2xl">ðŸ’¡</span>
                    </div>
                </div>
            </div>
            <div class="mt-6 flex justify-end space-x-3">
                <button id="modal-cancel-btn" class="px-4 py-2 bg-gray-200 dark:bg-gray-600 text-gray-800 dark:text-gray-200 font-semibold rounded-lg hover:bg-gray-300 dark:hover:bg-gray-500">Cancel</button>
                <button id="modal-save-btn" class="px-4 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700">Confirm Save</button>
            </div>
        </div>
    </div>

    <div id="toast-notification" class="toast"></div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- Element References ---
        const themeToggle = document.getElementById('theme-toggle');
        const themeIconLight = document.getElementById('theme-icon-light');
        const themeIconDark = document.getElementById('theme-icon-dark');
        const recordBtn = document.getElementById('record-btn');
        const recordStatus = document.getElementById('record-status');
        const listenBtn = document.getElementById('listen-btn');
        const listenIconPlay = document.getElementById('listen-icon-play');
        const listenIconPause = document.getElementById('listen-icon-pause');
        const listenStatus = document.getElementById('listen-status');
        const languageSelect = document.getElementById('language-select');
        const speedSelect = document.getElementById('speed-select');
        const diaryText = document.getElementById('diary-text');
        const saveBtn = document.getElementById('save-btn');
        const toast = document.getElementById('toast-notification');
        const entriesList = document.getElementById('entries-list');
        const noEntriesMsg = document.getElementById('no-entries-msg');
        const searchBar = document.getElementById('search-bar');
        
        const saveModal = document.getElementById('save-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalTitleInput = document.getElementById('modal-title-input');
        const modalTextInput = document.getElementById('modal-text-input');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const modalSaveBtn = document.getElementById('modal-save-btn');
        const moodSelectors = document.querySelectorAll('.mood-selector span');

        // --- State Management ---
        let isRecording = false;
        let entries = [];
        let currentEditIndex = null;
        let selectedMood = null;

        let currentUtterance = null;
        let wordSpans = [];
        let speechStartOffset = 0;
        let lastSpokenCharIndex = 0;

        // --- Theme Switcher ---
        const updateThemeIcon = () => {
            if (document.documentElement.classList.contains('dark')) {
                themeIconLight.classList.remove('hidden');
                themeIconDark.classList.add('hidden');
            } else {
                themeIconLight.classList.add('hidden');
                themeIconDark.classList.remove('hidden');
            }
        };
        themeToggle.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            localStorage.theme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
            updateThemeIcon();
        });

        // --- Speech Recognition (Voice-to-Text) ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            recordStatus.textContent = "Not supported.";
            recordBtn.disabled = true;
            listenBtn.disabled = true;
        }
        const recognition = new SpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = false;

        recognition.onstart = () => {
            isRecording = true;
            listenBtn.disabled = true;
            recordBtn.classList.add('pulse-red');
            recordStatus.textContent = 'Listening...';
            if (diaryText.innerText.trim().length > 0 && !diaryText.innerText.endsWith('\n\n')) {
                 diaryText.innerText += '\n';
            }
        };
        recognition.onend = () => {
            isRecording = false;
            listenBtn.disabled = false;
            recordBtn.classList.remove('pulse-red');
            recordStatus.textContent = 'Tap to start recording';
        };
        recognition.onerror = (e) => { console.error('Speech recognition error:', e.error); recordStatus.textContent = e.error === 'not-allowed' ? 'Mic access denied.' : 'Error.'; };
        recognition.onresult = (event) => {
            let transcript = event.results[event.results.length - 1][0].transcript.trim();
            diaryText.innerText += transcript + ' ';
        };


        // --- Speech Synthesis (Text-to-Speech) ---
        const synth = window.speechSynthesis;
        if (!synth) {
            listenBtn.disabled = true;
            listenStatus.textContent = "Not supported";
        }

        const resetHighlighting = () => {
             if (diaryText.innerHTML.includes('<span')) {
                diaryText.innerHTML = diaryText.innerText;
             }
        };
        
        const prepareForHighlighting = (text) => {
            wordSpans = [];
            const words = text.split(/(\s+)/);
            diaryText.innerHTML = '';
            words.forEach((word) => {
                const span = document.createElement('span');
                span.textContent = word;
                if (word.trim().length > 0) wordSpans.push(span);
                diaryText.appendChild(span);
            });
        };

        const handleSpeechBoundary = (event) => {
            if (event.name !== 'word') return;
            wordSpans.forEach(span => {
                span.style.backgroundColor = 'transparent';
                span.style.color = 'inherit';
            });
            lastSpokenCharIndex = event.charIndex + speechStartOffset;
            const wordIndex = event.charIndex === 0 ? 0 : diaryText.innerText.substring(0, lastSpokenCharIndex).trim().split(/\s+/).length -1;
            if (wordSpans[wordIndex]) {
                wordSpans[wordIndex].style.backgroundColor = '#93c5fd';
                wordSpans[wordIndex].style.color = 'black';
            }
        };
        
        const handleSpeechEnd = () => {
            recordBtn.disabled = false;
            listenBtn.classList.remove('pulse-green');
            listenIconPlay.classList.remove('hidden');
            listenIconPause.classList.add('hidden');
            listenStatus.textContent = 'Tap to listen';
            currentUtterance = null;
            setTimeout(resetHighlighting, 50); // Shorter delay for snappier feel
        };
        
        const startSpeech = (textToSpeak, offset = 0) => {
            synth.cancel(); // Always cancel previous speech
            
            prepareForHighlighting(diaryText.innerText);
            speechStartOffset = offset;
            lastSpokenCharIndex = offset;
            currentUtterance = new SpeechSynthesisUtterance(textToSpeak);
            currentUtterance.lang = languageSelect.value;
            currentUtterance.rate = parseFloat(speedSelect.value);
            currentUtterance.onboundary = handleSpeechBoundary;
            currentUtterance.onend = handleSpeechEnd;
            
            recordBtn.disabled = true;
            synth.speak(currentUtterance);
            
            listenStatus.textContent = "Speaking...";
            listenBtn.classList.add('pulse-green');
            listenIconPlay.classList.add('hidden');
            listenIconPause.classList.remove('hidden');
        };
        
        // --- Core Functions (Save, Load, etc.) ---
        const loadEntries = () => {
            entries = JSON.parse(localStorage.getItem('diaryEntries_v6') || '[]');
            refreshAndFilterEntries();
        };
        const saveEntries = () => {
            localStorage.setItem('diaryEntries_v6', JSON.stringify(entries));
        };
        const renderEntries = (entriesToRender) => {
            entriesList.innerHTML = '';
            noEntriesMsg.style.display = entriesToRender.length === 0 ? 'block' : 'none';
            [...entriesToRender].reverse().forEach(entry => {
                const entryElement = document.createElement('div');
                entryElement.className = 'bg-gray-100 dark:bg-gray-700 p-4 rounded-lg';
                const timestamp = new Date(entry.timestamp).toLocaleString();
                const moodHTML = entry.mood ? `<span class="text-2xl">${entry.mood}</span>` : '';
                entryElement.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div>
                            <h4 class="font-bold text-lg text-gray-800 dark:text-white">${entry.title}</h4>
                            <p class="text-xs text-gray-500 dark:text-gray-400 mb-2">${timestamp}</p>
                        </div>
                        ${moodHTML}
                    </div>
                    <p class="text-gray-800 dark:text-gray-200 whitespace-pre-wrap my-2">${entry.text}</p>
                    <div class="flex justify-end space-x-3 mt-3">
                        <button data-id="${entry.id}" class="copy-btn text-gray-500 text-xs hover:underline">Copy</button>
                        <button data-id="${entry.id}" class="edit-btn text-blue-500 text-xs hover:underline">Edit</button>
                        <button data-id="${entry.id}" class="delete-btn text-red-500 text-xs hover:underline">Delete</button>
                    </div>
                `;
                entriesList.appendChild(entryElement);
            });
        };
        const refreshAndFilterEntries = () => {
            const searchTerm = searchBar.value.toLowerCase();
            const filteredEntries = searchTerm ? entries.filter(e => e.title.toLowerCase().includes(searchTerm) || e.text.toLowerCase().includes(searchTerm)) : entries;
            renderEntries(filteredEntries);
        };
        const showToast = (message) => {
            toast.textContent = message; toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        };
        const openModal = (mode, entryId = null) => {
            const textContent = diaryText.innerText.trim();
            if (mode === 'new' && !textContent) { showToast("Please write something first!"); return; }
            if (mode === 'new') {
                modalTitle.textContent = 'Save New Entry';
                modalTitleInput.value = '';
                modalTextInput.value = textContent;
                currentEditIndex = null;
            } else {
                const entryIndex = entries.findIndex(e => e.id === entryId);
                if (entryIndex === -1) return;
                const entry = entries[entryIndex];
                modalTitle.textContent = 'Edit Entry';
                modalTitleInput.value = entry.title;
                modalTextInput.value = entry.text;
                selectedMood = entry.mood;
                currentEditIndex = entryIndex;
            }
            updateMoodSelection();
            saveModal.classList.remove('hidden');
            setTimeout(() => saveModal.querySelector('.modal-content').classList.remove('scale-95'), 10);
        };
        const closeModal = () => {
            saveModal.querySelector('.modal-content').classList.add('scale-95');
            setTimeout(() => {
                saveModal.classList.add('hidden'); currentEditIndex = null;
                selectedMood = null; updateMoodSelection();
            }, 300);
        };
        const updateMoodSelection = () => {
            moodSelectors.forEach(s => s.classList.toggle('selected', s.dataset.mood === s.selected));
        };

        // --- Event Listeners ---
        recordBtn.addEventListener('click', () => {
            if (isRecording) recognition.stop();
            else { recognition.lang = languageSelect.value; recognition.start(); }
        });
        
        listenBtn.addEventListener('click', () => {
            if (synth.speaking && !synth.paused) synth.pause();
            else if (synth.paused) synth.resume();
            else {
                const text = diaryText.innerText.trim();
                if (text) startSpeech(text, 0); else showToast("There's nothing to read!");
            }
        });

        synth.onpause = () => {
            listenBtn.classList.remove('pulse-green');
            listenIconPlay.classList.remove('hidden');
            listenIconPause.classList.add('hidden');
            listenStatus.textContent = "Paused";
        };
        synth.onresume = () => {
            listenBtn.classList.add('pulse-green');
            listenIconPlay.classList.add('hidden');
            listenIconPause.classList.remove('hidden');
            listenStatus.textContent = "Speaking...";
        };
        
        diaryText.addEventListener('click', () => {
            // New logic: On single click, cancel speech to enter editing mode cleanly.
            if (synth.speaking || synth.paused) {
                synth.cancel();
            }
        });

        diaryText.addEventListener('dblclick', () => {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            const range = selection.getRangeAt(0);
            const fullText = diaryText.innerText;
            let charCount = 0;
            const preCaretRange = range.cloneRange();
            preCaretRange.selectNodeContents(diaryText);
            preCaretRange.setEnd(range.endContainer, range.endOffset);
            charCount = preCaretRange.toString().length;
            let startIndex = fullText.lastIndexOf(' ', charCount - 1) + 1;
            if (charCount > 0 && startIndex === -1) startIndex = 0; // Handle first word
            
            const textToSpeak = fullText.substring(startIndex);
            startSpeech(textToSpeak, startIndex);
        });
        
        speedSelect.addEventListener('change', () => {
            if (synth.speaking || synth.paused) {
                const wasPaused = synth.paused;
                const textToResume = diaryText.innerText.substring(lastSpokenCharIndex);
                if(currentUtterance) currentUtterance.onend = null; // Prevent old end handler from firing
                synth.cancel();
                
                // Need a slight delay for cancel to fully process in some browsers
                setTimeout(() => {
                    startSpeech(textToResume, lastSpokenCharIndex);
                    if (wasPaused) {
                       setTimeout(() => synth.pause(), 50);
                    }
                }, 50);
            }
        });
        
        saveBtn.addEventListener('click', () => openModal('new'));
        modalCancelBtn.addEventListener('click', closeModal);
        modalSaveBtn.addEventListener('click', () => {
            const title = modalTitleInput.value.trim(), text = modalTextInput.value.trim();
            if (!title) { showToast("Please enter a title."); return; }
            if (currentEditIndex !== null) {
                entries[currentEditIndex] = { ...entries[currentEditIndex], title, text, mood: selectedMood };
                showToast('Entry updated!');
            } else {
                entries.push({ id: Date.now(), title, text, mood: selectedMood, timestamp: new Date().toISOString() });
                diaryText.innerText = '';
                showToast('Entry saved!');
            }
            saveEntries(); refreshAndFilterEntries(); closeModal();
        });
        moodSelectors.forEach(s => s.addEventListener('click', () => {
            selectedMood = s.dataset.mood === selectedMood ? null : s.dataset.mood;
            updateMoodSelection();
        }));
        entriesList.addEventListener('click', (e) => {
            const id = parseInt(e.target.dataset.id);
            if (!id) return;
            if (e.target.classList.contains('delete-btn')) {
                entries = entries.filter(en => en.id !== id);
                saveEntries(); refreshAndFilterEntries(); showToast('Entry deleted.');
            } else if (e.target.classList.contains('edit-btn')) openModal('edit', id);
            else if (e.target.classList.contains('copy-btn')) {
                const entry = entries.find(en => en.id === id);
                if (entry) navigator.clipboard.writeText(`Title: ${entry.title}\n\n${entry.text}`)
                    .then(() => showToast('Entry copied!'))
                    .catch(() => showToast('Could not copy text.'));
            }
        });
        searchBar.addEventListener('input', refreshAndFilterEntries);

        // --- Initial Load ---
        loadEntries();
        updateThemeIcon();
    });
    </script>
</body>
</html>

